<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document1</title>
    <style>
        p {
            font-size: 30px;
        }
    </style>
    <script src="mainn.js"></script>
</head>
<body>
    <h1>    Основные понятия   </h1>
    <p>
        Информатика (от информация и автоматика) — наука о методах и процессах сбора, хранения, обработки, передачи, анализа и оценки информации с применением компьютерных технологий, обеспечивающих возможность её использования для
        принятия решений.
        
    </p>
    <h1>    Структура информатики:   </h1>    
    <p>
        В информатике, как науке выделяют два основных раздела теоретическая и прикладная
        информатика. Теоретическая информатика использует математические методы для построения и изучения моделей обработки, передачи и использования информации. Прикладная информатика направлена на применение понятий и результатов теоретической информатики к решению конкретных задач в конкретных прикладных областях.
        
        
        В рамках данного курса нами будут рассмотрены следующие разделы теоретической информатики:
        Теория информация и кодирования - изучает количественную оценку информации, применяется при разработке алгоритмов как сжатия данных и систем хранения и передача данных.
        Архитектура компьютера - изучают концепции построения компьютеров.
        
        Теория алгоритмов и структур данных - связаны с изучением наиболее часто
        используемых вычислительных методов и оценкой их вычислительной эффективности,
        
        Теория языков программирования - изучает проектирование, реализацию, анализ и классификацию языков программирования в целом, а также изучают отдельные элементы языков программирования.
        
    </p>

    <h1>  Информация     </h1>    
    <p>
        Понятие информация является одним из фундаментальных в современной науке вообще и базовым для изучаемой нами информатики. Информацию наряду с веществом и энергией рассматривают в качестве важнейшей сущности мира, в котором мы живем. Однако, если задаться целью формально определить понятие «информация», то сделать это будет чрезвычайно сложно. Аналогичными «неопределяемыми» понятиями, например, в математике является «точка» или «прямая». Так, можно сделать некоторые утверждения, связанные с этими математическими понятиями, но сами они не могут быть определены с помощью более элементарных понятий.
        В простейшем бытовом понимании с термином «информация» обычно ассоциируются некоторые сведения, данные, знания и т.п. Информация передается в виде сообщений, определяющих форму и представление передаваемой информации. Примерами сообщений являются музыкальное произведение, телепередача, команды
         
        регулировщика на перекрестке, текст, распечатанный на принтере, данные, полученные в результате работы составленной вами программы и т.д. При этом предполагается, что имеются «источник информации» и «получатель информации».
        Сообщение от источника к получателю передается посредством какой-нибудь среды, являющейся в таком случае каналом связи (рис. 1.3).
        Канал связи – это совокупность технических средств, обеспечивающих передачу сигнала от источника к получателю. Каналы связи являются общим звеном любой системы передачи информации. По физической природе каналы связи делятся следующим образом:
        механические – используются для передачи материальных носителей информации;
        акустические – передают звуковой сигнал;
        оптические – передают световой сигнал;
        электрические – передают электрический сигнал.
        Так, при передаче речевого сообщения в качестве такого канала связи можно рассматривать воздух, в котором распространяются звуковые волны, а в случае передачи письменного сообщения (например, текста, распечатанного на принтере) каналом сообщения можно считать лист бумаги, на котором напечатан текст.
        
        Стоит заметить, что соответствие между сообщением и информацией не является взаимно однозначным, для одной и той же информации существуют различные, передающие ее сообщения. Более того одно и то же сообщение может передавать различную информацию для разных адресатов. Так, например, вы хотите сообщить о неисправности компьютера. Для инженера из группы технического обслуживания сообщение «компьютер сломался» явно содержит больше информации, чем для вахтера. Но, в свою очередь, для инженера сообщение «не включается дисплей» содержит информации больше, чем первое, поскольку в большей степени снимает неопределенность, связанную с причиной неисправности компьютера. Как видно, одно и то же сообщение для различных пользователей несет различную информацию.
        
    </p>

    <h1>    Непрерывная и дискретная информация  </h1>    
    <p>
        Чтобы сообщение было передано от источника к получателю, необходима некоторая материальная субстанция - носитель информации. Сообщение, передаваемое с помощью носителя, назовем сигналом. В общем случае сигнал - это изменяющийся во времени физический процесс. Такой процесс может содержать различные характеристики (например, при передаче электрических сигналов могут изменяться напряжение и сила тока). Та из характеристик, которая используется для представления сообщений, называется параметром сигнала.
        В случае когда параметр сигнала принимает последовательное во времени конечное число значений (при этом все они могут быть пронумерованы), сигнал называется дискретным, а сообщение, передаваемое с помощью таких сигналов -дискретным сообщением. Информация, передаваемая источником, в этом случае также называется дискретной. Если же источник вырабатывает непрерывное сообщение (соответственно
         
        параметр сигнала - непрерывная функция от времени), соответствующая информация называется непрерывной. Пример дискретного сообщения - процесс чтения книги, информация в которой представлена текстом, т.е. дискретной последовательностью отдельных значков (букв). Примером непрерывного сообщения служит человеческая речь, передаваемая модулированной звуковой волной; параметром сигнала в этом случае является давление, создаваемое этой волной в точке нахождения приемника - человеческого уха.
        Непрерывное сообщение может быть представлено непрерывной функцией, заданной на некотором отрезке [а, Ь] (см. рис. 1.4). Непрерывное сообщение можно преобразовать в дискретное (такая процедура называется дискретизацией). Для этого из бесконечного множества значений этой функции (параметра сигнала) выбирается их определенное число, которое приближенно может характеризовать остальные значения. Один из способов такого выбора состоит в следующем. Область определения функции разбивается точками x1, x2,... хn, на отрезки равной длины и на каждом из этих отрезков значение функции принимается постоянным и равным, например, среднему значению на этом отрезке; полученная на этом этапе функция называется в математике ступенчатой. Следующий шаг - проецирование значений «ступенек» на ось значений функции (ось ординат). Полученная таким образом последовательность значений функции у1, у2, ... уn. является дискретным представлением непрерывной функции, точность которого можно неограниченно улучшать путем уменьшения длин отрезков разбиения области значений аргумента.
        Ось значений функции можно разбить на отрезки с заданным шагом и отобразить каждый из выделенных отрезков из области определения функции в соответствующий отрезок из множества значений (рис. 1.4). В итоге получим конечное множество чисел, определяемых, например, по середине или одной из границ таких отрезков.
        Таким образом, любое сообщение может быть представлено как дискретное, иначе говоря последовательностью знаков некоторого алфавита.
        Возможность дискретизации непрерывного сигнала с любой желаемой точностью (для возрастания точности достаточно уменьшить шаг) принципиально важна с точки зрения информатики. Компьютер - цифровая машина, т. е - внутреннее представление информации в нем дискретно. Дискретизация входной информации (если она непрерывна) позволяет сделать ее пригодной для компьютерной обработки.
        
    </p>

    <h1>    Кодирование информации   </h1>    
    <p>
        Информация передается в виде сообщений. Дискретная информация записывается с помощью конечного набора символов. Например, для сообщений на русском языке
 
        такими символами будут прописные и строчные русские буквы, знаки препинания, пробел и цифры.
        Символом будем называть элемент некоторого конечного множества или набора отличных друг от друга элементов. Множество символов, на котором определен их порядок будем называть алфавитом.
        Дискретное сообщение представляет собой последовательность символов. При этом обычно их разбивают на конечные последовательности, называемые словами. Требование упорядоченности символов алфавита позволяет говорить о возможности лексикографического (алфавитного) упорядочивания слов над этим алфавитом. Длиной слова называют количество составляющих его букв.
        Кодированием будем называть правило отображения одного набора символов в другой набор символов, при этом символы исходного набора или набора образов могут являться последовательностями (словами) над некоторым другим набором знаков. Кодом будем называть множество образов при таком отображении. Обращение этого отображения (в случае его однозначности) будем называть декодированием.
        
    </p>

    <h1>      Измерение информации </h1>    
    <p>
        Информация (в смысле данных) всегда связана с материальным носителем: это может быть сигнал в любой материальной форме, числовой, символьный код на печатной основе и т.д. Поскольку, любой материальный объект можно измерить, то это относится и к информации.
        Определить понятие «количество информации» довольно сложно. В решении этой проблемы существуют два основных подхода. Исторически они возникли почти одновременно. В конце 40-х годов XX века один из основоположников кибернетики американский математик Клод Шеннон развил вероятностный подход к измерению количества информации, а работы по созданию ЭВМ привели к «объемному» подходу.
        
    </p>

    <h1>   Вероятностный подход    </h1> 
    <h1>     Формула Хартли   </h1>    
    <p>
        Количество информации I, содержащееся в сообщении, о том, что произошло одно из N равновероятных событий, определяется по формуле 𝐼 = 𝑙𝑜𝑔2𝑁, часто используют в виде 𝑁 = 2𝐼.
    </p>
    <h1>   Формула Шеннона      </h1>    
    <p>
        Количество информации I, содержащееся в сообщении, о том, что произошло одно из	N	событий	имеющих	различные	вероятности	𝑝𝑖,	определяется	по	формуле
        𝐼 = − ∑𝑁   𝑝𝑖𝑙𝑜𝑔2(𝑝𝑖),  при  этом  количество  информации  содержащееся  в  сообщении  о
         
        наступлении конкретного события определяется как
         
        𝐼𝑖 = −𝑙𝑜𝑔2
         
        (𝑝𝑖)
         
        1
        = 𝑙𝑜𝑔2 (   ).
         
        𝑝𝑖
        
        В качестве примера определим количество информации, связанное с появлением каждого символа в сообщениях, записанных на русском языке. Будем считать, что русский алфавит состоит из 33 букв и знака «пробел» для разделения слов. По формуле Хартли получим I = log2 34 ≈ 5,09 бит.
        
        Однако, в словах русского языка (равно как и в словах других языков) различные буквы встречаются неодинаково часто. Ниже приведена таблица вероятностей частоты употребления различных знаков русского алфавита, полученная на основе анализа текстов
         
        больших по объемов. Воспользуемся для подсчета формулой Шеннона и получим I ≈ 4,72 бит. Полученное значение I, как и можно было предположить, меньше вычисленного ранее. Величина I, вычисляемая по формуле Хартли, является максимальным количеством информации, которое могло бы приходиться на один знак.
        
        i	Символ	Р(i)	i	Символ	P(i)	i	Символ	Р(i)
        1	Пробел	0,175	13		0,028	24	Г	0.012
        2	0	0,090	14	М	0,026	25	Ч	0,012
        3	Е	0,072	15	Д	0,025	26	И	0,010
        4	Ё	0,072	16	П	0,023	27	X	0,009
        5	А	0,062	17	У	0,021	28	Ж	0,007
        6	И	0,062	18	Я	0,018	29	Ю	0,006
        7	Т	0,053	19	Ы	0,016	30	Ш	0.006
        8	Н	0,053	20	З	0.016	31	Ц	0,004
        9	С	0,045	21	Ь	0,014	32	Щ	0,003
        10	Р	0,040	22	Ъ	0,014	33	Э	0,003
        11	В	0,038	23	Б	0,014	34	Ф	0,002
        12	Л	0,035						
        Частотность букв русского языка
        
    </p>
    <h1>     Объемный подход   </h1>    
    <p>
        Рассмотрим алфавит, состоящий из двух знаков 0 и 1. Если считать, что со знаками 0 и 1 в двоичном алфавите связаны одинаковые вероятности их появления (Р(0) = Р(1) = 0,5), то количество информации на один знак при двоичном кодировании будет равно I = lоg2 2
        = 1 бит. Т.е. один двоичный символ передает lоg2 2 = 1 – один бит информации. И такой символ стали называть битом. Bit (бит) – это сокращение от английского binary digit, что дословно переводится как двоичный разряд. Таким образом, количество информации в битах, заключенное в некотором двоичном слове, равно числу двоичных знаков в нем.
        Объем информации, записанной двоичными знаками в памяти компьютера или на внешнем носителе информации подсчитывается просто по количеству требуемых для такой записи двоичных символов. При этом, в частности, невозможно нецелое число битов (в отличие от вероятностного подхода).
        Для удобства использования введены и более крупные, чем бит, единицы количества информации. Так, двоичное слово из восьми знаков содержит один байт информации, 210=1024 байта образуют килобайт (Кб), 210=1024 килобайта - мегабайт (Мб), а 1024 мегабайта - гигабайт (Гб) и т.д.
        Между вероятностным и объемным количеством информации соотношение неоднозначное, однако можно точно сказать, что если некоторое сообщение допускает измеримость количества информации обоими подходами (объёмным и вероятностным) то они не обязательно совпадают, при этом вероятностное количество информации не может быть больше объемного.
         
        
    </p>
    <h1>    Системы счисления    </h1>    
    <p>
        Большинство физических величин изменяется непрерывно. Например, напряжение в электрическом проводе, частота колебаний или распределение массы – все это параметры, изменяющиеся непрерывно. Цифровые системы, с другой стороны, представляют информацию в виде дискретно меняющихся переменных с конечным числом строго определённых значений.
        Одной из наиболее ранних цифровых систем стала Аналитическая Машина Чарльза Бэббиджа, которая использовала переменные с десятью дискретными значениями. Начиная с 1834 года и до 1871 года Бэббидж разрабатывал и пытался построить этот механический компьютер. Шестеренки Аналитической Машины могли находится в одном из десяти фиксированных положений, а каждое такое положение было промаркировано от 0 до 9 подобно механическому счетчику пробега автомобиля. Каждый ряд шестеренок такой машины обрабатывал одну цифру. В своем механическом компьютере Бэббидж использовал 25 рядов шестеренок таким образом, чтобы машина обеспечивала вычисления с точностью до 25-го знака. Каждая шестеренка в машине Бэббиджа содержит log210 = 3,322 бит информации, поскольку она может находиться в одном из 23,322 = 10 уникальных положений. В отличие от машины Бэббиджа большинство электронных компьютеров использует двоичный (бинарный) код. В случае двоичного кода высокое напряжение – это единица, а низкое напряжение – нуль, поскольку гораздо легче оперировать двумя уровнями напряжения, чем десятью.
        Мы все привыкли работать с десятичными числами. Однако, в цифровых системах, построенных на единицах и нулях, использование двоичных восьмеричных или шестнадцатеричных чисел зачастую более удобно. В данном разделе мы рассмотрим эти системы счисления.
        
    </p>
    <h1>   Основные понятия     </h1>    
    <p>
        Системой счисления называют символический метод записи чисел. Системы счисления можно разделить на два класса: позиционные и непозиционные. В позиционных системах счисления один и тот же символ (цифра) в записи числа имеет различные значения в зависимости от его места (разряда) в записи числа. В непозиционных системах счисления значение символа не зависит от его места в записи числа. Наиболее известной непозиционной системой счисления является римская (хотя есть еще и древнеегипетская, ионийская...): (I-1, V-5, X-10, L-50, C-100, D-500, M-1000). В этой системе число III=3, т.е. символ I обозначает 1 не зависимо от позиции. Использование таких систем крайне неудобно (589=DLXXXIX, а 590= DXC). Далее будем рассматривать только позиционные системы счисления.
        Позиционной системой счисления (далее системой счисления) будем называть пару (α, A), где число α будем называть основанием системы счисления, а множество символов A={0,1... α-1}-алфавитом этой системы счисления. При этом α=|A|.
        Тогда любое целое число x представимо в виде конечной суммы:
         
        Тогда любое рациональное число x представимо в виде бесконечной суммы:
         
         
        где первая сумма соответствует целой части, а вторая – дробной.
        Конечной записью обладают только рациональные числа представимые в виде
        где первая сумма соответствует целой части, а вторая – дробной.
        
    </p>
    <h1>     Десятичная система счисления   </h1>    
    <p>
        (10, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
        Еще в начальной школе нас всех научили считать и выполнять различные арифметические операции в десятичной (decimal) системе счисления. Такая система использует десять арабских цифр: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 – столько же, сколько у нас пальцев на руках. Числа больше 9 записываются в виде строки цифр. Причем, цифра, находящаяся в каждой последующей позиции такой строки, начиная с крайней правой цифры, имеет
        «вес», в десять раз превышающий «вес» цифры, находящейся в предыдущей позиции. Именно поэтому десятичную систему счисления называют системой по основанию (base)
        10.	Справа налево «вес» каждой позиции увеличивается следующим образом: 1, 10, 100, 1000 и т.д. Позицию, которую цифра занимает в строке десятичного числа, называют разрядом или декадой. Чтобы избежать недоразумений при одновременной работе с более чем одной системой счисления, основание системы обычно указывается путем добавления цифры позади и чуть ниже основного числа: 974210.
        
    </p>
    <h1>   Двоичная система счисления     </h1>    
    <p>
        (2, {0, 1})
        Одиночный бит может принимать одно из двух значений, 0 или 1. Несколько битов, соединенных в одной строке, образуют двоичное (binary) число. Каждая последующая позиция в двоичной строке имеет вдвое больший «вес», чем предыдущая позиция, так что двоичная система счисления – это система по основанию 2. В двоичном числе «вес» каждой позиции увеличивается справа налево следующим образом: 1, 2, 4, 8, 16, 32, 64, 128, 256... и т.д.
        Перевод из двоичной системы счисления в десятичную выполняется суммированием произведений соответствующих цифр на соответствующую степень 2.
        Представить число 101102 в десятичной системе:
        101102 = 1*24+0*23+1*22+1*21+0*20 = 16+4+2 = 2210
        Перевод из десятичной системы счисления в двоичную выполняется одним из двух способов:
        1.	Начинаем с левой позиции двоичного числа. Находим наибольшую степень числа 2 меньше или равную заданному числу, ставим 1 в этой позиции и вычитаем значение этой степени 2 из заданного числа. Для всех степеней 2 меньше найденной наибольшей степени выполняем следующее: сравниваем его с текущим значением числа, если число меньше, то в соответствующем разряде пишем 0, если число больше или равно, то в соответствующем разряде пишем 1 и вычитаем соответствующую степень 2 из числа. Если на каком-то шаге текущее значение искомого числа обращается в 0, то в оставшихся разрядах записываем 0.
        2.	Начинаем с правой позиции двоичного числа. Последовательно делим исходное число на 2. Остаток от деления записываем в очередную позицию. Выполняем до тех пор, пока делимое не станет равно 0.
        Представить число 8410 в двоичной системе:
         
        1.Первый способ:	
        84-64=20:	1xxxxxx;
        20<32:	10xxxxx;
        20>16, 20-16=4:	101xxxx;
        4<8:	1010xxx;
        4=4, 4-4=0:	10101xx;
        0:	1010100;
        2.Второй способ:	
        84 2=42+0:	xxxxxx0;
        42/2=21+0:	xxxxx00;
        22/2=10+1:	xxxx100;
        10/2=5+0:	xxx0100;
        5/2=2+1:	xx10100;
        2/2=1+0:	x010100;
        1/2=0+1:	1010100;
        
        Сложение и умножение чисел в двоичной системе выполняется столбиком. Заметим, что при двоичном сложении 1+1 возникает перенос единицы в старший разряд – так же как и в десятичной арифметике, при этом, если результат сложения превышает выделенное для него количество разрядов, говорят о сложении с переполнением.
        
        1011	1101	1101
             + 11 	 	+ 101 	 	* 101 
        1110	10010	1101
                +0000
                  +1101	
                1000001
        
        
    </p>
    <h1>    Восьмеричная и шестнадцатеричная системы счисления    </h1>    
    <p>
        (8, {0, 1, 2, 3, 4, 5, 6, 7})
        (16, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F})
        
        Использование длинных двоичных чисел для записи и выполнения математических расчетов на бумаге утомительно и чревато ошибками. Однако длинное двоичное число можно разбить на группы по три (триада) или четыре (тетрада) бит, каждая из которых представляет одну из 8 или 16 двоичныых комбинаций соответственно. Именно поэтому зачастую бывает удобнее использовать для работы систему счисления по основанию 8 называемую восьмеричной (octal) или 16 называемую шестнадцатеричной (hexadecimal). В восьмеричной системе для записи чисел используются цифры от 0 до7, в шестнадцатеричной используются цифры от 0 до 9 и буквы от A до F.
        Интересно, что термин hexadecimal введен обиход корпорацией IBM в 1963 году и является комбинацией греческого слова hexi (шесть) и латинского decem (десять). Правильнее было бы использовать латинское же слово sexa (шесть), но термин
         
        sexadecimal воспринимался бы несколько неоднозначно.
        Так, как 8 и 16 являются степенями 2, то преобразования из этих систем счисления в двоичную систему счисления и обратно выполняются очень просто, поскольку каждая восьмеричная цифра прямо соответствует 3-х разрядному двоичному числу, а каждая шестнадцатеричная - 4-разрядному, соответствие представлено в таблице:
        
        octal	decimal	binary		hexadecimal	Decimal	binary
        0	0	000		0	0	0000
        1	1	001		1	1	0001
        2	2	010		2	2	0010
        3	3	011		3	3	0011
        4	4	100		4	4	0100
        5	5	101		5	5	0101
        6	6	110		6	6	0110
        7	7	111		7	7	0111
            8	8	1000
            9	9	1001
            A	10	1010
            B	11	1011
            C	12	1100
            D	13	1101
            E	14	1110
            F	15	1111
        
        Преобразовать число 11010012 в восьмеричную и шестнадцатеричную системы счисления:
        11010112 = 0011010112 = 001 101 0112 = 1538
        11010112 = 011010112 = 0110 10112 = 6B16
        Преобразовать числа 2578 и 2CD16 в двоичную систему счисления:
        2578 = 010 101 1112 = 0101011112 = 101011112
        2CD16 = 0010 1100 11012 = 0010110011012 = 10110011012
        Преобразования из/в десятичную систему счисления, а так же арифметические операции в восьмеричной и шестнадцатеричной системах счисления производятся по аналогии с двоичной системой счисления.
         
        
    </p>
    <h1>    Представление данных в ЭВМ    </h1>    
    <p>
        Представление данных в ЭВМ

        Целые числа без знака
        Целые числа без знака представляются своим двоичным кодом. Очевидно, в этом случае диапазон представляемых значений определяется выражением [0, 2N-1], где N – число бит выделенных на хранение числа. Поскольку память адресуется байтами, то обычно N кратно 8.
        Целые числа со знаком
        До сих пор мы с вами рассматривали двоичные числа без знака (unsigned), т.е. только неотрицательные числа. Однако для вычислений необходимо уметь оперировать и с отрицательными числами. Получается, что для хранения знака числа, необходимо выделить дополнительный двоичный разряд (0 – «+», 1 – «-»). Существует несколько способов представления двоичных чисел со знаком (signed), но наиболее широко применяются два: прямой код (sign/magnitude) и дополнительный код (two’s complement).
        Прямой код 
        Представление целых двоичных чисел со знаком похоже на привычную запись в десятичной системе, когда сначала идёт знак «-», а затем записывается абсолютное значение числа. Прямой код это представление числа в двоичной системе счисления, при котором старший бит, используется для хранения знака, а остальные биты для хранения абсолютного значения этого числа. Очевидно, что диапазон значений представимых с помощью N-битного двоичного числа в прямом коде составляет [-2N-1+1, 2N-1-1].
        Записать числа 5 и -5 в четырехбитовом прямом коде:
        Оба числа имеют абсолютное значение 510 = 01012, соответственно 510 = 01012 и
        -610 = 11012.
        Несмотря на привлекательную простоту представления чисел в прямом коде, этот способ представления имеет ряд недостатков:
        1.	Наличие значений +0 = 00...0002 и -0 = 10...0002, которые соответствуют одному значению 0. А представление одной и той же величины двумя различными способами чревато ошибками.
        2.	Стандартный способ сложения двоичных чисел со знаком, записанных в прямом коде не дает ожидаемых результатов. Сложите, например, числа 5 и -5 из предыдущего примера.
        В связи с указанными недостатками для представления прямой код используют только для представления положительных двоичных чисел, а для отрицательных двоичных чисел используют так называемый дополнительный код.
        Дополнительный код 
        Дополнительный код положительного числа равен прямому коду этого числа. Дополнительный код отрицательного числа x равен 2N-|x|, где N - количество разрядов, отведенное на хранение числа.
        Получить дополнительный N-разрядный код отрицательного числа можно по следующему алгоритму:
        1.	модуль отрицательного числа представить прямым кодом в N двоичных разрядах;
         
        2.	значение всех бит инвертировать (таким образом, получается N-разрядный
        обратный код исходного числа);
        3.	к полученному обратному коду прибавить единицу.
        Обратное преобразование, т.е. нахождение абсолютного значения отрицательного числа представленного дополнительным N-разрядным кодом выполняется по той же схеме.
        Записать число -5 в четырехбитовом дополнительном коде:
        Число имеют абсолютное значение 510 = 01012, соответственно обратный код числа:  10102,  прибавим  к  обратному  коду   единицу:   10102 + 00012 = 10112.   Итого  -  510 = 10112.
        Найти десятичное значение числа 11012 в дополнительном коде:
        Число имеет 1 в старшем разряде, соответственно оно должно быть отрицательным. Что бы найти его абсолютное значение найдем обратный код числа, он равен 00102, прибавим к обратному коду единицу: 00102 + 00012 = 00112 = 310. Итого
        11012 = -310.
        Дополнительный код используется для упрощения выполнения арифметических операций. Если бы вычислительная машина работала с прямыми кодами положительных и отрицательных чисел, то при выполнении арифметических операций следовало бы выполнять ряд дополнительных действий. Например, при сложении нужно было бы проверять знаки обоих операндов и определять знак результата. Если знаки одинаковые, то вычисляется сумма операндов и ей присваивается тот же знак. Если знаки разные, то из большего по абсолютной величине числа вычитается меньшее и результату присваивается знак большего числа. То есть при таком представлении чисел (в виде только прямого кода) операция сложения реализуется через достаточно сложный алгоритм. Если же отрицательные числа представлять в виде дополнительного кода, то операция сложения, в том числе и разного знака, сводится к их поразрядному сложению.
        Вычислить a) -510 + 610, b) -610 + 510 с помощью чисел в четырехбитовом дополнительном коде:
        a) -510 + 610 = 10112 + 01102 = 100012 отбросим пятый бит и получим
        четырехбитный результат 00012  = 110.
        b) -610  + 510 = 10102  + 01012  = 11112 = -110.
        Вычитание одного двоичного числа из другого осуществляется путём преобразования вычитаемого в дополнительный код и последующего сложения с уменьшаемым.
        Вычислить a) 710 - 410, b) 410 - 710 с помощью чисел в четырехбитовом дополнительном коде:
        a) 710 - 410 =710 + (-410) = 01112 + 11002 = 100112 отбросим пятый бит и получим
        четырехбитный результат 00112 = 310.
        b) 410 - 710 = 410 + (-710) = 01002 +10012 = 11012 = -310.
        Т.е. при таком представлении отрицательного числа операции сложения и вычитания можно реализовать одной схемой сложения.
        В дополнительном коде 0 имеет единственное представление 00...0002, а число 10...0002 представляет максимальное отрицательное значение -2N-1. Диапазон значений представимых с помощью N-битного двоичного числа в дополнительном коде составляет
         
        [-2N-1, 2N-1-1]. В случае, если необходимо увеличить количество бит для представления числа, записанного в дополнительном коде, то необходимо скопировать значение знакового бита в добавленные старшие разряды нового числа. Эта операция называется знаковым расширением (sign extension).
        Представить в восмибитном дополнительном коде числа 3 и -3, записанные в четырехбитном дополнительном коде:
        310  = 01012 = 000001012.
        -310 = 11012  = 111111012.
        
    </p>
    <h1>    Переполнение результата в целочисленной арифметике   </h1>    
    <p>
        Цифровые системы обычно оперируют числами с заранее определенным и фиксированным количеством разрядов. Ситуацию, когда результат сложения превышает выделенное для него количество разрядов, называют переполнением (overflow). В этом случае дополнительный бит отбрасывается, а оставшийся результат будет ошибочным (1310 + 610 = 11012 + 01102 = 100112 = 00112 = 310). Когда речь идёт о числах со знаком, к ошибочным результатам может привести и ситуация переноса разряда в старший (знаковый) бит. Так, например, сумма двух положительных чисел может дать отрицательный результат (510 + 610 = 01012 + 01102 = 10112 = -510). С другой стороны, при работе с отрицательными числами в дополнительном коде зачастую происходит выход за разрядность, который игнорируется (-510 + 610 = 10112 + 01102 = 100012 = 00012 = 110). Как же определить арифметическую корректность результата?
        Необходимо рассмотреть две ситуации:
        1.	Числа без знака: Необходимо отслеживать перенос из старшего бита. Результат сложения двух двоичных N-разрядных чисел будет арифметически корректным тогда и только тогда, когда значение переноса из старшего бита равно 0.
        2.	Числа со знаком: Необходимо отслеживать два последних переноса: из старшего бита и в старший бит. Результат сложения двух двоичных N- разрядных чисел будет арифметически корректным тогда и только тогда, когда значения переносов 11 или 00. Соответственно если значения переносов 01 или 10, значит имело место переполнение.
        Вычислить a) 1110 + 910, b) 310 + 910 с помощью чисел без знака в четырехбитовом двоичном коде и определить корректность результата в смысле переполнения:
        a) 1110 + 910 = 10112 + 10012 = 100112, переносы(10110): соответственно четырехбитовый результат 00112 = 310 не является арифметически корректным.
        b) 510 + 710 = 01012 +01112 = 11002, переносы(01110): соответственно
        четырехбитовый результат 11002 = 1210 арифметически корректен.
        Вычислить a) 510 + 610, b) -510 - 610, c) -510 + 610 с помощью чисел в четырехбитовом дополнительном коде и определить корректность результата в смысле переполнения:
        a) 510 + 610 = 01012 + 01102 = 10112, переносы(01000): соответственно четырехбитовый результат 10112 = -510 не является арифметически корректным.
        b) -510 - 610 = -510 + (-610) = 10112 + 10102 = 101012, переносы(10100):
        соответственно четырехбитовый результат 01012 = 510 не является
         
        арифметически корректным.
        c) -510 + 610 = 10112 +01102 = 100012 переносы(11100), два последних переноса равны 11, пятый бит можем отбросить, оставшийся четырехбитовый результат 00012 = 110 арифметически корректен.
         
        
    </p>
    <h1>    Символьные данные    </h1>    
    <p>
        Каждая символ принадлежит определенному алфавиту, в котором символы следуют друг за другом и, следовательно, могут быть пронумерованы последовательными целыми числами, т.е. каждому символу можно сопоставить целое положительное число и назвать его кодом этого символа. Именно этот код и хранится в памяти компьютера, а при выводе на экран или бумагу «преобразовывается» в соответствующий ему символ.
        Соответствие символов определенного алфавита с их числовыми кодами формирует так называемую таблицу кодировок или кодовую страницу. Другими словами, каждый символ конкретного алфавита имеет свой числовой код в соответствии с определенной таблицей кодировок.
        
    </p>
    <h1>     Кодировки стандарта ASCII   </h1>    
    <p>
        В 60-х годах XX века в американском национальном институте стандартизации (ANSI) была разработана таблица кодирования символов, которая впоследствии была использована во всех операционных системах. Эта таблица называется ASCII (American Standard Code for Information Interchange – американский стандартный код для обмена информацией). Чуть позже появилась расширенная версия ASCII. В соответствие с таблицей кодирования ASCII для представления одного символа выделяется 1 байт (8 бит). Набор из 8 ячеек может принять 28 = 256 различных значений. Первые 128 значений (от 0 до 127) постоянны и формируют так называемую основную часть таблицы, куда входят десятичные цифры, буквы латинского алфавита (заглавные и строчные), знаки препинания (точка, запятая, скобки и др.), а также пробел и различные служебные символы (табуляция, перевод строки и др.). Значения от 128 до 255 формируют дополнительную часть таблицы, где принято кодировать символы национальных алфавитов.
        Поскольку национальных алфавитов огромное множество, то расширенные ASCII- таблицы существуют во множестве вариантов, более того для некоторых языков существует несколько таблиц кодировок. Так, например, для русского языка существуют следующие распространённые таблицы кодировок:
        КОИ8-R — русская кодировка, получившая распространения в Unix-подобных операционных системах и электронной почте. Символы кириллицы расположены не в алфавитном порядке. Их разместили в верхнюю половину таблицы так, чтобы позиции кириллических символов соответствовали их фонетическим аналогам в английском алфавите. Это значит, что при отбрасывании старшего бита каждого символа, получается читаемый текст на «транслите»: фраза «Русский Текст» превратится в «rUSSKIJ tEKST». Содержит символы псевдографики.
        CP866 — русская кодировка, использовавшаяся на компьютерах IBM в системе MS DOS. Кириллические символы идут в алфавитном порядке. Содержит символы псевдографики.
        Windows-1251 — русская кодировка, использовавшаяся в русскоязычных версиях операционной системы Windows с начала 90-х годов. Кириллические символы идут в алфавитном порядке. Символы псевдографики заменены на более актуальные символы, встречающиеся в типографике.
        Такой подход к кодированию символьных данных имеет определённые недостатки:
        1.	В рамках одного языка существуют несколько кодировок, при несовпадении которых,     текст     становится     нечитаемым:     КОИ8-R (Привет     мир!),  CP866 (Ё╥╔╫┼╘ ═╔╥!), Windows-1251 (рТЙЧЕФ НЙТ!). Поэтому любой текст должна сопровождать информация о том, в какой кодировке он записан.
         
        2.	В алфавитах некоторых языков (например, языки некоторых стран Азии) слишком много символов и они не помещаются в отведенные им позиции с 128 до 255 однобайтовой кодировки.
        3.	Так как одному тексту сопоставляется одна таблица кодировки, то это делает невозможным представление многоязычного текста (когда в одном тексте используются несколько языков, например, русский, английский и французский).
        
    </p>
    <h1>    Кодировки стандарта UNICODE     </h1>    
    <p>
        Чтобы решить эти проблемы разом была разработана кодировка Unicode. Стандарт предложен  в  1991  году  некоммерческой  организацией  «Консорциум  Юникода»   (англ. Unicode Consortium, Unicode Inc.). Применение этого стандарта позволяет закодировать очень большое число символов из разных письменностей. В Unicode для кодирования символов предоставляется 31 бит (4 байта за вычетом одного бита, который решили не использовать, дабы не решать проблему «знаковости» этих данных). Количество возможных комбинаций дает огромное число: 231 = 2147483684 (т.е. более двух миллиардов) символов. Поэтому Unicode описывает алфавиты всех известных языков, даже «мертвых», включает многие математические и иные специальные символы. Стоит сказать, что кодовая таблица Unicode постоянно расширяется: так, например, одним из недавно добавленных символов стал символ российского рубля, после того как получил официальный статус (в декабре 2013, его принял Центральный банк РФ, а в 2014 году, знак появился в Unicode версии 7.0).
        В Unicode первые 128 символов (коды 0000—007F) совпадают с основной частью таблицы ASCII, всевозможные кириллические символы занимают 432 кодовых значения (коды 0400—04FF, 0500—052F, 2DE0—2DFF, A640—A69F), унифицированные иероглифы (китайские, корейские, вьетнамские и т.д.) занимают 20992 кодовых значений (коды 4E00— 9FFF), встречаются и вовсе экзотические языки, например древнеперсидская клинопись (коды 103A0—103DF), а так же и символы, не имеющие ничего общего с письменностью, например игральные карты (коды 1F0A0—1F0FF). Детально посмотреть разделы Unicode можно на сайте http://unicode-table.com/ru/blocks/.
        Так, как на представление одного символа отведен 31 бит, то логично предположить, что для хранения одного символа необходимо использовать 4 байта памяти. Ввиду того, что наиболее востребованные языки и символы расположены в начале таблицы, большая часть из этих четырёх байтов всегда будет нулевой, а это пустая трата памяти. Это привело к созданию кодировок переменной длины, которые используют различное количество байтов для различных символов. Символы в формате Unicode имеют несколько широко распространённых кодировок:
        UTF-8 — кодирование, обеспечивающее наилучшую совместимость со старыми системами, использовавшими 8-битные символы. Текст, состоящий только из символов с номером меньше 128, при записи в UTF-8 превращается в обычный текст ASCII. Остальные символы Юникода кодируются последовательностями длиной от двух до шести байт.
        UTF-16 — каждый символ кодируется двухбайтовым словом с использованием всех возможных диапазонов значений 0000 до FFFF. Символы, имеющие код длиннее 16 бит кодируются парой 16-битных слов с применением кода со сдвигом.
        UTF-32 — один из способов кодирования символов из Unicode, использующий для кодирования любого символа ровно 32 бита и является прямым представлением его кодовой позиции.
        Форматы UTF-8 и UTF-16 являются кодировками переменной длины и позволяют сократить объём памяти, требуемый для хранения символьных данных по сравнению с
         
        UTF-32. Так, например в UTF-8 символы латиницы кодируются одним байтом, символы кириллицы – двумя байтами. В связи с особенностями технической реализации формат UTF-16 позволяет кодировать только 1112064 кодовых значений, поэтому в настоящее время в связи с поддержкой этого формата в Unicode фактически используется именно столько кодовых значений. Стоит заметить, что этого пока вполне достаточно, т.к. все символы, используемые в основных языках мира, которые называют основной многоязычной плоскостью (basic multilingual plane) уместились в первые 65536 кодовых значений (коды 0000—FFFFF), а последний зарезервированный символ в таблице на настоящий момент имеет код 1F9FF16=129535.
        
        основная часть ASCII таблицы
         
         
        
        КОИ8-R (80-FF)
        
        CP-1251 (80-FF)
         
        
    </p>
    <h1>    Представление данных в ЭВМ

        Вещественные числа
            </h1>    
    <p>
        В вычислительных задачах необходимо уметь оперировать не только с целыми, но и с дробными числами. Рассмотрим представление чисел с фиксированной и с плавающей точкой (запятой), с помощью которых можно представить действительные числа. Числа с фиксированной точкой это аналог десятичной записи, а числа с плавающей точкой аналог экспоненциальной записи.
    </p>
    <h1>    Числа с фиксированной точкой     </h1>    
    <p>
        Представление с фиксированной точкой подразумевает разделитель между битами целой и дробной части. Так, например число 010110112 можно интерпретировать как число 0101.10112,       с       четырьмя       битами       целой       и       дробной       части       равное   22 + 20 + 2-1 + 2-3 + 2-4 = 4 + 1 + 1/2 + 1/8 + 1/16 = 4 + 1 + 0.5 + 0.125 + 0.625 = 5.687510.  Так же
        можно записать указанное число в дополнительном коде 1010.01012, тогда его значение
        будет уже равно -5.687510.
        Диапазон значений чисел с фиксированной точкой, у которых на дробную часть отведено M<N бит, записанных в N-битном дополнительном коде, будет составлять [-2N-M-1, 2N-M-1-2-M], однако следует помнить, что далеко не все числа из этого диапазона могут быть записаны в таком формате.
        Рассмотрим представление чисел с фиксированной точкой в формате (2.2), записанных в четырёхбитном дополнительном коде:
        
        x2	|x2|	x10		x2	|x2|	x10
        00.00	00.00	0		10.00	10.00	-2
        00.01	00.01	0.25		10.01	01.11	-1.75
        00.10	00.10	0.5		10.10	01.10	-1.5
        00.11	00.11	0.75		10.11	01.01	-1.25
        01.00	01.00	1		11.00	01.00	-1
        01.01	01.01	1.25		11.01	00.11	-0.75
        01.10	01.10	1.5		11.10	00.10	-0.5
        01.11	01.11	1.75		11.11	00.01	-0.25
        В рассмотренном формате представимы 16 чисел в диапазоне [-2, 1.75] с шагом 0.25.
        Достоинствами представления чисел в формате с фиксированной точкой являются простота и наглядность представления чисел, а также простота алгоритмов реализации арифметических операций. Недостатками являются узкий диапазон значений и небольшая точность, недостаточные для решения расчётных задач.
        
    </p>
    <h1>     Числа с плавающей точкой    </h1>    
    <p>
        Этот способ представления опирается на экспоненциальную запись действительных чисел. В науке для записи очень больших и очень маленьких чисел уже давно используется способ, основанный на том, что любое действительное число x в системе счисления с
 
        основанием α можно записать в виде:
         
        x  M *  E , где M называют мантиссой, а
         
        показатель степени E – порядком числа (или экспонентой).
        Для десятичной системы это выглядит очень привычно, например: скорость света в
         
        вакууме составляет 3*108 м/сек или число Авогадро, равное 6,022*1023 1/моль. Мантисса – это по сути своей цифры числа, а порядок – величина, показывающая, в каком месте мантиссы надо поставить точку. Такая система записи чисел называется представлением с плавающей точкой, видимо, по той причине, что точка «плавает» по мантиссе в зависимости от значения порядка.
        Очевидно,    что    представление    чисел    в    таком     виде     неоднозначно: 25.324 = 2.5324*101 = 0.0025324*104 = 2532.4*10-2 и т.д. Нормальной формой числа с плавающей запятой называется такая форма, в которой мантисса (без учёта знака) в десятичной системе находится на полуинтервале [0; 1). Однако такая форма записи так же допускает неоднозначность записи чисел: 25.324 = 0.25324*102 = 0.025324*103 = 0.0025324*104 и т.д. Для исключения такой неоднозначности используют нормализованную форму числа, в которой мантисса десятичного числа принимает значения из диапазона [1; 10), а мантисса двоичного числа принимает значения из диапазона [1; 2). То есть в мантиссе, слева от запятой находится ровно одна цифра отличная от 0. В такой форме любое число записывается единственным образом (2.5324*101). Недостатком такой формы является невозможность представления числа 0, поэтому для его записи используют специальную последовательность бит, как будет показано далее. Старший разряд (целая часть числа) мантиссы двоичного числа (кроме 0) в нормализованном виде всегда равен 1 (так называемая неявная единица), поэтому при записи мантиссы числа в ЭВМ старший разряд можно не записывать, сэкономив таким образом один бит, для записи дробной части мантиссы. В позиционных системах счисления с основанием большим, чем 2, этого замечательного свойства нет, поскольку целая часть там может быть не только единицей.
        Много лет производители аппаратного обеспечения использовали различные, порой несовместимые форматы представления вещественных чисел, что было очень неудобно. В 1985 году Институт инженеров электротехники и электроники (Institute of Electrical and Electronics Engineers (IEEE) решил эту проблему, определив стандарт представления чисел с плавающей точкой (IEEE 754), который в настоящее время используется повсеместно.
        Число с плавающей точкой состоит из набора двоичных разрядов, условно разделенных на так называемые знак (sign), порядок (exponent) и мантиссу (mantissa). Вот пример такого 16-и разрядного числа:
        
        знак	порядок	Мантисса
        0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
        15	14				10	9									0
        
        Наиболее значимый бит используется для указания знака числа (0 — если число положительное, 1 — если число отрицательное). Мантисса записывается в нормализованном виде, своей дробной частью в двоичной  системе  счисления,  а порядок - как целое число в коде со смещением.
        Поскольку необходимо обеспечить хранение как очень больших, так и очень малых значений, то необходимо учитывать, что порядок может иметь знак. Использование дополнительного кода, для этих целей, не самый лучший вариант, т.к. сравнение экспонент в этом случае требует учитывать знак числа, поэтому было предложено использовать код со смещением.
        При использовании N-разрядного кода со смещением (offset binary) целочисленный отрезок [0; 2N-1] сдвигается влево на некоторое смещение K, после чего числа из
         
        смещенного диапазона [-K; 2N-1-K] последовательно кодируются кодами от 000...02 до 111...12.
        Для числа с плавающей точкой, на хранение порядка в котором отведено N бит смещение рассчитывается как K=2N-1-1 и далее говоря о коде со смещением будем понимать именно такую величину смещения. В этом случае диапазон представимых значений будет [-2N-1+1; 2N-1] и кодируется значениями из диапазона [0; 2N-1] и значения от
        -2K-1+1 до 2K-1 располагаются последовательно, в порядке возрастания их двоичного кода. Использование кода со смещением позволяет производить операции над порядками, как над беззнаковыми числами, что упрощает операции сравнения, сложения и вычитания порядков, а также упрощает операцию сравнения самих нормализованных чисел. Стоит отметить, что значения порядка -2N-1+1 и 2N-1 используются для представления особых значений, и фактически используемый диапазон значений порядка равен [-2N-1+2; 2N-1-1].
        Представить число -5410 в восьмибитном двоичном коде со смещением.
        1)	Найдём величину смещения 28-1-1=12710;
        1)	Найдём смещённое значение исходного числа -5410 + 12710 = 7310;
        2)	Найдем восьмибитный двоичный код смещенного числа 7310 = 010010012;
        В соответствии со стандартом IEEE 754 выделяют следующие типы чисел с плавающей точкой:
        Число половинной точности (half precision) — компьютерный формат представления чисел, занимающий в памяти половину машинного слова (в случае 32- битного компьютера —16 бит или 2 байта). В силу невысокой точности этот формат представления чисел с плавающей запятой обычно используется в видеокартах, где небольшой размер и высокая скорость работы важнее точности вычислений.
        Число одинарной точности (single precision) — компьютерный формат представления чисел, занимающий в памяти одно машинное слово (в случае 32-битного компьютера — 32 бита или 4 байта). Используется для работы с вещественными числами везде, где не нужна высокая точность. В языке C соответствует типу данных float.
        Число двойной точности (double precision) — компьютерный формат представления чисел, занимающий в памяти два машинных слова (в случае 32-битного компьютера — 64 бита или 8 байт). Часто используется благодаря очень высокой точности, даже несмотря на двойной расход памяти и сетевого трафика относительно чисел одинарной точности. В языке C соответствует типу данных double.
        Число четверной точности (quadruple precision) — компьютерный формат представления чисел, занимающий в памяти четыре машинных слова (в случае 32-битного компьютера — 128 бит или 16 байт). Используется в случае необходимости крайне высокой точности. Обычно этот формат реализуется программно, случаи аппаратной реализации крайне редки. В языке C соответствует типу данных long double, если формат реализован аппаратно.
        
        
        Формат	Разрядность	
        Диапазон
            Всего	Знак	Порядок	Мантисса	
        Half precision	16	1	5	10	±6.1*10-5..±65504
        Single precision	32	1	8	23	±1.18*10-38..±3.4*1038
        Double precision	64	1	11	52	±2.2*10-308..±1.8*10308
        Quadruple precision	128	1	15	112	±3.4*10-4932..±1.2*104932
         
        Так же стандарт IEEE 754 подразумевает особые случаи для представления таких значений, которые не могут быть представлены обычным образом:
        Ноль (со знаком): Как было замечено ранее, в нормализованной форме числа с плавающей точкой невозможно представить ноль. Поэтому для его представления зарезервированы специальные значения мантиссы и порядка — число считается нулём, если все его биты, кроме знакового, равны нулю. При этом в зависимости от значения бита знака ноль может быть как положительным, так и отрицательным. Несмотря на то, что и возможно получить отрицательный ноль в качестве результата вычисления выражения, при сравнении отрицательный ноль равен положительному.
        Неопределенность (NaN): NaN — это аббревиатура от фразы "not a number". NaN является результатом арифметических операций, если во время их выполнения произошла ошибка. Значение NaN представлено как число, в котором все двоичные разряды порядка
        — единицы, а мантисса не нулевая. Любая операция с NaN возвращает NaN. Значение NaN
         
        можно	получить	в	результате	следующих	вычислений:
        √−1, 𝑙𝑜𝑔2(−5) и т.д.
         
        ∞ , 0
        ∞  0
         
        , 0 ∗ ∞,
         
        Бесконечность: В число с плавающей точкой можно записать значение +∞ или -∞.
        Как и нули со знаком, бесконечности позволяют получить хотя бы близкий к правильному результат вычисления в случае переполнения. Число с плавающей точкой считается равным бесконечности, если все двоичные разряды его порядка — единицы, а мантисса равна нулю. Знак бесконечности определяется знаковым битом числа. Получить бесконечность можно при переполнении и при делении ненулевого числа на ноль. При этом выполняется следующее соотношение:
        𝑥	+∞, 𝑥 > 0,
        = {𝑁𝑎𝑁, 𝑥 = 0, 0	−∞, 𝑥 < 0.
        
        Значение	Знак	Порядок	Мантисса
        ±0	X	00000000	00000000000000000000000
        ±∞	X	11111111	00000000000000000000000
        NaN	X	11111111	XXXXXXXXXXXXXXXXXXXXXXX
        
        Представить число -146.82812510 в формате с плавающей точкой одинарной точности.
        1)Найдём двоичное представление числа: -146.82812510 = -10010010.1101012; 2)Нормализуем число: -10010010.1101012 =-1.00100101101012*27;
        3)	Вычислим смещенный порядок числа: т.к. результат необходимо представить
        в формате одинарной точности, то смещение будет равно 12710, соответственно значение смещенного порядка равно 710 + 12710 =
        = 000001112 + 011111112 = 100001102;
        4)	Запишем результат: т.к. число отрицательное в знаковый бит пишем 1, затем последовательно записываем смещенный порядок и дробную часть нормализованной мантиссы, дополняя справа нулями до 23 разрядов 11000011000100101101010000000000.
        Определить число, записанное в формате с плавающей точкой одинарной точности следующим кодом: 001111100110001100000000000000002.
         
        1)	Разберём код числа на составляющие: в старшем разряде значение 0, соответственно число положительное; число задано в формате одинарной точности, соответственно следующие 8 разрядов (011111002) представляют смещенный порядок числа, а оставшиеся 23 (110001100000000000000002) — дробную часть мантиссы; беря во внимание неявную 1 и отбросив незначащие нули, получим мантиссу равную 1.11000112;
        2)	Вычислим порядок числа: смещенный порядок числа равен 011111002 = 12410 т.к. число задано в формате одинарной точности, то смещение будет равно 12710, соответственно значение порядка равно 12410 - 12710 = -310;
        3)Денормализуем число: 1.11000112*2-3 = 0.00111000112;
        4)Найдём десятичное представление: 0.00111000112 = 2-3 + 2-4 + 2-5 + 2-9 + 2-10 =
        = 1/8 + 1/16 + 1/32+ 1/512 + 1/1024 = 0.221679687510;
        Проверить результаты представления десятичных чисел в формате с плавающей точкой можно на сайте http://www.binaryconvert.com.
        
    </p>
    <h1>     Особенности вещественной арифметики   </h1>    
    <p>
        Далеко не все десятичные дроби представимы в виде конечных двоичных последовательностей, так например число 0.610 = 0.1(0011)2. Соответственно в нормализованном виде такое число будет иметь бесконечную периодическую мантиссу 0.610 = 1.(0011)2*2-2. Поскольку для представления мантиссы выделяется конечное число разрядов, то её необходимо каким-то образом округлять. При округлении мантиссы она сначала усекается до N разрядов, а затем, если в N+1 разряде находится 1, то к мантиссе прибавляют 1 в младшем разряде. Так, например мантисса числа 0.610 = 1.(0011)2*2-2 в формате одинарной точности будет иметь вид 00110011001100110011010. Сама по себе абсолютная погрешность представления не высока, но если использовать такое значение в цикле, то можем получить накопленную погрешность, которая уже будет значительна.
        float a = 0.0f, b = 0.1f*1000, c = 0.1f; for (int i=0; i<1000; i++)
        {
        a += c;
        }
        printf("a=%f;\n", b); //100.000000 printf("c=%f;\n", a); //99.999046
        Отсюда же следует некорректность сравнения вещественных чисел на точное равенство:
        float a = 0.0f, b = 0.1f, c = 0.9f; for (int i=0; i<9; i++)
        {
        a += b;
        }
        (a == c) ? printf("equal") : printf("not equal"); //not equal
        Значение,       полученное       в        результате        вычислений,        представляется        как a = 001111110110011001100110011010002=0.900000095410, а число, с которым сравнивается это значение c = 001111110110011001100110011001102= 0.899999976210, поэтому сравнение на точное равенство не даст корректного результата.
        При нахождении разности близких по модулю чисел может происходить катастрофическая потеря точности. В этом случае влияние абсолютной погрешности округления на результат оказывается существенным, что приводит к значительному росту относительной погрешности результата.
         
        float a = 0.3f, b = 0.298f, c = 0.29999998f; printf("%.7e\n", a-b); // 2.0000041e-3 printf("%.7e\n", a-c); // 2.9802322e-8
        В первом случае относительная погрешность результата составляет 0.0002% а во втором уже 49.0116%.
        При выполнении операций сложения и вычитания над числами с плавающей точкой выполняется выравнивание порядков, т.е. оба числа приводятся к одному (максимальному) порядку, что может приводить к исчезновению значащих разрядов у чисел с меньшим порядком, т.к. разрядность представления конечна. В этой связи в арифметике с плавающей точкой, существуют такие условия, при которых свойство ассоциативности (a*b)*c = a*(b*c) не выполняется для любых арифметических операций. Так, например (1+108)-108 = 0 <> 1+(108 - 108), что является абсурдным, с точки зрения математики.
        float a = 1.0f, b = 1e8f, c= -1e8f, d=(a+b)+c, e=a+(b+c); printf("d=%f; e=%f;", d, e);// d=0.000000; e=1.000000;
        Такой эффект возникает вследствие выравнивания порядков: в приведенном примере число    a = 00111111100000000000000000000000,    имеет     порядок     равный     0,     число   b = 01001100101111101011110000100000, имеет порядок равный 26. При выполнении сложения число a приводится к порядку 26, т.е. мантисса сдвигается на 26 разрядов вправо 1.00000000000000000000000 = 0.00000000000000000000000001*226 и единственный
        значащий разряд выходит за разрядную сетку.
        Так же стоит упомянуть о таком понятии как машинное эпсилон. Машинным эпсилон называется минимальное положительное число ε, для которого выполняется
        1.0 + ε > 1.0. Очевидно, что эта величина будет зависеть от разрядности мантиссы, и для разных    типов    данных     будет     представлять     различные     значения:     для     float    ε = 1*2-23 = 1.1921*10-7, для double ε = 1*2-52 = 2.2204*10-16. Машинное эпсилон одна из наиболее важных характеристик вещественной арифметики, т.к. по сути, определяет точность представления чисел. Два (отличных от нуля) числа являются одинаковыми с точки зрения некоторой машинной арифметики, если их относительная разность по модулю меньше машинного эпсилон для этой арифметики.
        Ввиду вышесказанного рекомендуется учитывать следующие особенности вещественной арифметики:
        1.	Уже при записи вещественных чисел возникают ошибки округления, которые нарастают при выполнении арифметических операций.
        2.	Неразумно сравнивать два вещественных числа на строгое равенство, вместо этого следует требовать, что бы модуль разности двух чисел не превосходил некоторое число ε.
        3.	Самой опасной операцией с точки зрения округления в арифметике с плавающей запятой является — это вычитание. При вычитании близких чисел значимые разряды могут потеряться, что может в разы увеличить относительную
        погрешность.
        4.	Сложение и вычитание с очень малыми (относительно первого слагаемого) числами может никак не сказаться на результате.
        Если в некоторой вычислительной задаче возникают проблемы 3 - 4, то необходимо пересмотреть вычислительную схему.
         
        
    </p>
    <h1>   Архитектура компьютера     </h1>    
    <p>
        Архитектурой называется описание структуры и принципов работы компьютера без подробностей технической реализации. Различают Принстонскую и Гарвардскую архитектуру вычислительных машин. Эти архитектурные варианты были предложены в конце 40-х годов прошлого столетия специалистами, соответственно, Принстонского и Гарвардского университетов США для разрабатываемых ими моделей компьютеров, и легли в основу архитектуры современных ЭВМ.
    </p>
    <h1>    Принстонская архитектура (Машина Фон Неймана)    </h1>    
    <p>
        После войны Джон Фон Нейман работал профессором Принстонского университета США. В 1946 году Фон Нейман (с соавторами) описал в техническом докладе конкретную ЭВМ, обладающую рядом новых особенностей. Со временем стало ясно, что эти особенности желательно включать в архитектуру всех разрабатываемых в то время компьютеров. А вскоре пришло и понимание того, что эти новые свойства вычислительных машин, по сути, описывают архитектуру некоторого абстрактного универсального вычислителя, который сейчас принято называть машиной Фон Неймана. Эта машина является абстрактной моделью ЭВМ. Подавляющее большинство вычислительных машин на сегодняшний день, по сути, являются машиной Фон Неймана. Исключение составляют лишь отдельные разновидности систем для параллельных вычислений, в которых отсутствует счетчик команд, не реализована классическая концепция переменной и имеются другие существенные принципиальные отличия от классической модели.

        Принципиальная схема машины Фон Неймана
        
        На рисунке приведена схема машины Фон Неймана: толстыми (двойными) стрелками показаны потоки команд и данных, а тонкими – передача между отдельными устройствами компьютера управляющих и информационных сигналов. Выполнение каждой команды приводит к выработке последовательности управляющих сигналов, которые заставляют узлы компьютера совершать те или иные действия. С помощью же информационных сигналов одни узлы компьютера сообщают другим узлам о том, что они успешно выполнили действия, предписанные управляющими сигналами, либо зафиксировали ошибки в своей работе.
        Как видно из приведенного рисунка, машина Фон Неймана состоит из памяти, устройств ввода/вывода и центрального процессора (ЦП). Центральный процессор, в свою очередь, состоит из устройства управления (УУ) и арифметико-логического устройства (АЛУ). Далее рассмотрим все узлы машины Фон Неймана и выполняемые ими функции.
         
        
    </p>
    <h1>   Память      </h1>    
    <p>
        Память – это линейная (упорядоченная) и однородная последовательность некоторых элементов, называемых ячейками. В любую ячейку памяти другие устройства машины (по толстым стрелкам на схеме) могут записать и считать информацию. Ячейки памяти нумеруются от нуля до некоторого положительного числа N. Адресом ячейки называется её номер. Каждая ячейка состоит из более мелких частей, именуемых разрядами и нумеруемых также от нуля и до некоторого числа M. Количество разрядов M определяет разрядность памяти. Каждый разряд может хранить одну цифру в некоторой системе счисления. В большинстве ЭВМ используется двоичная система счисления, т.к. это более выгодно с точки зрения инженерной реализации. В этом случае каждый разряд хранит одну двоичную цифру или один бит информации.
        Содержимое ячейки называется машинным словом. С точки зрения архитектуры, машинное слово – это минимальный объём данных, которым могут обмениваться между собой различные узлы вычислительной машины (по толстым стрелкам на схеме). Из каждой ячейки памяти можно считать копию машинного слова и передать её в другое устройство компьютера, при этом оригинал не меняется. При записи в память старое содержимое ячейки пропадает и заменяется новым машинным словом.
        Любое машинное слово представляет собой либо команду, либо подлежащие обработке данные. Данные и команды неотличимы друг от друга – в памяти и те, и другие представляются некоторым набором разрядов, причем по внешнему виду машинного слова нельзя определить, что оно собой представляет – команду или число. Таким образом, программа хранится в памяти вместе с данными.
        Ячейки памяти расположены не в основной памяти, а в других устройствах ЭВМ называют регистровой памятью или регистрами.
        
    </p>
    <h1>   Арифметико-Логическое Устройство      </h1>    
    <p>
        Арифметико-логическое устройство может выполнять следующие действия.
        1.	Считать машинное слово из некоторой ячейки памяти в один из своих регистров.
        2.	Записать в некоторую ячейку памяти содержимое одного из своих регистров.
        3.	Выполнять различные операции над данными в своих регистрах, например, сложить содержимое двух регистров R1 и R2, и поместить результат этой операции на третий регистр A (Accumulator).
        
    </p>
    <h1>   Устройство управления      </h1>    
    <p>
        Устройство управления организует процесс выполнения программы. Оно управляет всеми остальными устройствами ЭВМ, посредством посылки управляющих сигналов, подчиняясь которым остальные устройства производят определенные действия, предписанные этими сигналами.
        Программа – непустое множество записанных в памяти машинных команд, задающих действия, описывающих шаги работы алгоритма. Каждая команда состоит из кода операции и адресной части. Код операции определяет, какую команду должен исполнить процессор. Адресная часть указывает, где в памяти компьютера хранятся операнды и куда поместить результат выполнения операции. Машинные команды делят на 3 группы:
        1.	Команды передачи данных – позволяют перемещать данные из одного места в другое (например, копирование машинного слова из памяти в регистр АЛУ).
        2.	Арифметико-логические команды – позволяют выполнять арифметические и логические преобразований над данными, с помощью АЛУ (сложение, вычитание, конъюнкция, дизъюнкция и т.д.).
         
        3.	Команды управления – позволяют управлять выполнением программы (например, команда останова или перехода).
        Машина, выполняя записанную в её памяти программу, функционирует автоматически, без участия человека, если только такое участие не предусмотрено в самой программе, например, при вводе данных. Пример устройства, которое может выполнять команды, как и ЭВМ, но не в автоматическом режиме – обычный (непрограммируемый) калькулятор. Последовательность команд для калькулятора задаёт сам человек.
        Устройство управления выполняет некоторую команду от начала до конца, а затем по определенному правилу выбирает следующую команду для выполнения, затем следующую и т.д. При этом каждая команда либо сама явно указывает на команду, которая будет выполняться за ней, (такие команды называются командами перехода), либо следующей будет выполняться команда из ячейки, расположенной в памяти непосредственно вслед за той ячейкой, в которой хранится только что выполненная команда. Этот процесс продолжается, пока не будет выполнена специальная команда останова, либо при выполнении очередной команды не возникнет аварийная ситуация (например, деление на ноль).
        
    </p>
    <h1>    Взаимодействие УУ и АЛУ     </h1>    
    <p>
        Устройство управления тоже имеет свои регистры: регистр или счетчик адреса (IP – instruction pointer) на нем всегда хранится адрес следующей исполняемой команды и регистр команд (IR – instruction register) на нем всегда хранится текущая выполняемая команда. Фактически процесс выполнения программы УУ можно условно описать следующим циклом, который получил название машинный цикл:
        ВЫПОЛНЯТЬ
        1.	Загрузить команду с адресом IP на регистр IR;
        2.	Инкрементировать значение IP;
        3.	Выполнить команду на IR, если это команда перехода загрузить в IP адрес перехода;
        ПОКА (НЕ ОСТАНОВ) И (НЕ ОШИБКА)
        Выполнение команды подразумевает дешифрацию машинного слова на регистре IR, т.е. разбор на код операции и операнды и последующее выполнение этой операции. Непосредственно выполнение арифметических и логических операций возложено на арифметико-логическое устройство. Так, например, выполнение команды z = x + y приводит к выполнению следующей последовательности элементарных операций:
        1.	Загрузить в регистр R1 содержимое ячейки памяти с адресом x;
        2.	Загрузить в регистр R2 содержимое ячейки памяти с адресом y;
        3.	Сложить содержимое регистров R1 и R2 (результат помещается в регистр - аккумулятор A);
        4.	Переслать копию содержимого регистра A в ячейку памяти с адресом z;
        Здесь каждая элементарная операция инициируется УУ, оно посылает соответствующий управляющий сигнал, предписывая АЛУ выполнить соответствующую операцию.
        
    </p>
    <h1>  Устройства ввода и вывода       </h1>    
    <p>
        Устройство ввода обеспечивает занесение данных из «внешнего мира» в оперативную память. Устройство вывода обеспечивает отображение данных, содержащихся в оперативной памяти. На уровне рассмотрения концептуальной архитектуры ЭВМ более подробные характеристики устройств ввода и вывода нам не потребуются.
 

    </p>
    <h1>    Основные принципы архитектуры Фон Неймана     </h1>    
    <p>
        Принцип двоичного кодирования. Вся информация, как данные, так и команды, кодируются двоичными цифрами 0 и 1. Интерпретация двоичных данных зависит от их формата. Последовательность битов в формате, имеющая определенный смысл, называется полем.
        Принцип программного управления. Программа состоит из набора команд, выполняющихся процессором автоматически в определенной последовательности. Выборка программы из памяти осуществляется с помощью счетчика команд. Этот регистр процессора последовательно увеличивает хранимый в нем адрес очередной команды на длину команды. А так как команды программы расположены в памяти друг за другом, то тем самым организуется выборка цепочки команд из последовательно расположенных ячеек памяти. Если же нужно после выполнения команды перейти не к следующей, а к какой-то другой, используются команды условного или безусловного перехода, которые заносят в счетчик команд номер ячейки памяти, содержащей следующую команду. Выборка команд из памяти прекращается после достижения и выполнения команды останова (программирование).
        Принцип адресности. Структурно основная память состоит из перенумерованных ячеек. Процессору в произвольный момент времени доступна любая ячейка. Отсюда следует возможность давать имена областям памяти так, чтобы к запомненным в них значениям можно было впоследствии обращаться или менять их в процессе выполнения программ с использованием присвоенных имен (переменные).
        Принцип однородности памяти. Команды и данные хранятся в одной и той же памяти и внешне в памяти неразличимы. Распознать их можно только по способу использования; то есть одно и то же значение в ячейке памяти может использоваться и как данные, и как команда, и как адрес в зависимости лишь от способа обращения к нему. Это позволяет производить над командами те же операции, что и над числами, и, соответственно, команды одной программы могут быть получены как результат исполнения другой программы. Эта возможность лежит в основе трансляции — перевода текста программы с языка высокого уровня на язык конкретной вычислительной машины.
        Подавляющее большинство вычислительных машин на сегодняшний день – фон- неймановские машины. Исключение составляют лишь отдельные разновидности систем для параллельных вычислений, в которых отсутствует счетчик команд, не реализована классическая концепция переменной и имеются другие существенные принципиальные отличия от классической модели. Рассмотренная архитектура имеет как свои достоинства, так и недостатки:
        Наличие общей памяти позволяет оперативно перераспределять ее объем для хранения команд и данных в зависимости от решаемых задач. Таким образом, обеспечивается возможность более эффективного использования имеющегося объема оперативной памяти в каждом конкретном случае применения.
        Использование общей шины для передачи команд и данных значительно упрощает отладку, тестирование и текущий контроль функционирования системы, повышает ее надежность.
        Необходимость последовательной выборки команд и обрабатываемых данных по общей системной шине. При этом общая шина становится «узким местом» (bottleneck –
        «бутылочное горло»), которое ограничивает производительность цифровой системы.
         
        
    </p>
    <h1>   Гарвардская архитектура     </h1>    
    <p>
        Гарвардская архитектура была разработана Говардом Эйкеном в конце 1930-х годов в Гарвардском университете с целью увеличить скорость выполнения вычислительных операций и оптимизировать работу памяти. Она характеризуется физическим разделением памяти команд (программ) и памяти данных. Каждая память соединяется с процессором отдельной шиной, что позволяет одновременно с чтением-записью данных при выполнении текущей команды производить выборку и декодирование следующей команды. Благодаря такому разделению потоков команд и данных и совмещению операций их выборки реализуется более высокая производительность, чем при использовании Принстонской архитектуры. Гарвардская архитектура не использовалась вплоть до конца 70-х годов, ввиду сложности технической реализации.
        Недостатки Гарвардской архитектуры связаны с необходимостью проведения большего числа шин, а также с фиксированным объемом памяти, выделенной для команд и данных, назначение которой не может оперативно перераспределяться в соответствии с требованиями решаемой задачи. Поэтому приходится использовать память большего объема, коэффициент использования которой при решении разнообразных задач оказывается более низким, чем в системах с Принстонской архитектурой. Однако развитие микроэлектронной технологии позволило в значительной степени преодолеть указанные недостатки, поэтому в настоящее время Гарвардская архитектура широко применяется во внутренней структуре современных высокопроизводительных микропроцессоров, где используется отдельная кэш-память для хранения команд и данных. В то же время во внешней структуре большинства микропроцессорных систем реализуются принципы Принстонской архитектуры.
         
        
    </p>
    <h1>    Выполнение программы

        Внутреннее представление программы
            </h1>    
    <p>
        Программа представляет собой совокупность алгоритма и данных. Как было сказано ранее, и то и другое хранится в виде двоичных машинных слов в общей памяти, причём команды и данные по своему внешнему виду не различимы. Как же различаются тогда данные и команды их обработки? Это обеспечивается благодаря такому принципу организации памяти, как сегментация. Сегментом называется непрерывная область памяти, хранящая данные одного назначения, имеющая собственную систему относительной адресации и ограничения доступа. При трансляции программы разные ее компоненты попадают в различные сегменты программного кода.
        В памяти компьютера программа организована следующим образом:
        •	Сегмент данных (Data, bss-сегмент и куча)
        •	Стек
        •	Сегмент кода
         
        
        Data содержит статические и глобальные переменные, которые явно инициализируются значениями. Этот сегмент может быть далее разбит на ro-data (read only data) – сегмент данных только для чтения, в котором хранятся не изменяемые значения, и rw-data (read write data) – сегмент данных для чтения и записи. Например, глобальные переменные
        s[] = "hello world"; bool readonly = true; static int i = 10
        будут храниться в rw-области.
        А для выражения типа
        const char* string = "hello world"
        указатель будет храниться в rw-области, а строковый литерал "hello world" в ro-области.
        BSS-сегмент (block started by symbol) содержит неинициализированные глобальные переменные, или статические переменные без явной инициализации. Этот сегмент начинается непосредственно за data-сегментом. Обычно загрузчик программ инициализирует bss область при загрузке приложения нулями. Дело в том, что в data области переменные инициализированы – то есть затирают своими значениями выделенную область памяти. Так как переменные в bss области не инициализированы
         
        явно, то они теоретически могли бы иметь значение, которое ранее хранилось в этой области, а это уязвимость, которая предоставляет доступ до, возможно, приватных данных. Поэтому загрузчик вынужден обнулять все значения. За счёт этого и неинициализированные глобальные переменные, и статические переменные по умолчанию равны нулю.
        Куча – начинается за BSS сегментом и начиная оттуда растёт, соответственно с увеличением адреса. Этот участок используется для выделения на нём памяти с использованием функции malloc и для очистки с помощью функции free во время исполнения программы.
        Стековый сегмент - большинство языков программирования используют его для хранения локальных переменных и аргументов, переданных в функцию. Набор значений, которые кладутся на стек одной функцией, называются фреймом. Один фрейм хранит как минимум одно значение - адрес возврата. Когда функция возвращает управление, стековый фрейм уничтожается, после чего, размещенные там значения более не доступны. Стек устроен достаточно просто — данные обрабатываются в соответствии с принципом
        «последним пришёл — первым обслужен» (LIFO). По этой причине, для отслеживания содержания стека не нужно сложных управляющих структур – достаточно всего лишь указателя на верхушку стека. Добавление данных в стек и их удаление – быстрая и четко определенная операция. Более того, многократное использование одних и тех же областей стекового сегмента приводит к тому, что они, как правило, находятся в кеше процессора, что еще более ускоряет доступ. Стэк растет "навстречу" куче, то есть с увеличением стека адрес вершины стека уменьшается.
        Сегмент кода, или текстовый сегмент, или просто текст, содержит исполняемые инструкции. У него фиксированный размер и обычно он используется только для чтения, если же в него можно писать, то архитектура поддерживает самомодификацию. Сегмент кода располагается после начала стека, поэтому в случае роста он [стек] не перекрывает сегмент кода.
        
    </p>
    <h1>   Виды памяти (переменных)     </h1>    
    <p>
        В традиционных языках программирования, существуют три вида памяти: статическая, стековая и динамическая. Конечно, с физической точки зрения никаких различных видов памяти нет: оперативная память - это массив байтов, каждый байт имеет адрес, начиная с нуля. Когда говорится о видах памяти, имеются в виду способы организации работы с ней, включая выделение и освобождение памяти, а также методы доступа.

        Статическая память (сегменты DATA и BSS) выделяется еще до начала работы программы, на стадии компиляции и сборки. Статические переменные (в языке C это глобальные и статические переменные) имеют фиксированный адрес, известный до запуска программы и не изменяющийся в процессе ее работы. Статические переменные создаются и инициализируются до входа в функцию main, с которой начинается выполнение программы.
        
        Стековая память. Локальные, или стековые, переменные - это переменные, описанные внутри функции. Память для таких переменных выделяется на стеке в момент входа в функцию (или блок) и освобождается в момент выхода из функции (или блока). При этом захват и освобождение памяти происходят практически мгновенно, т.к. меняется только содержимое регистра SP хранящего адрес вершины стека. Локальные переменные можно использовать для организации рекурсивных вызовов и параллельных вычислений, поскольку при повторном входе в функцию на стеке создается новый набор локальных
         
        переменных (фрейм), а предыдущий не разрушается. Такое свойство функции называется реентерабельностью, от англ. re-enter able - возможность повторного входа. Функции работающие со статическими или глобальными данными таким свойством не обладают, в этом случае требуется использовать механизмы синхронизации, и логика программы значительно усложняется. Всегда следует избегать использования глобальных и статических переменных, если можно обойтись локальными. Локальные переменные создаются при входе в функцию и уничтожаются после выхода из нее, поэтому их нельзя использовать в качестве данных, разделяемых между несколькими функциями. К тому же, размер стека ограничен (так, например в компиляторе Visual Studio для архитектуры x86 и x64 по умолчанию выделяется стек объемом 1 МБ.) и соответственно стек может переполниться (например, при глубокой рекурсии), что приведет к аварийному завершению программы. Поэтому локальные переменные не должны иметь большого размера, в частности, не рекомендуется использовать большие массивы в качестве локальных переменных.
        
        Динамическая память представляет собой практически неограниченный ресурс памяти, которую зачастую называют кучей (heap). Динамическая память выделяется во время работы программы, причем программа может захватывать участки динамической памяти требуемого размера. После использования ранее захваченный участок динамической памяти следует освободить, тогда этот участок памяти помечается как свободный и может быть распределен заново. В языке C, интерфейсом для работы с кучей является соответственно функции malloc() и free(). В отличие от стека, память, выделенная в куче, сохраняется после того, как функция, вызвавшая выделение этой памяти, завершится. Динамическую память рекомендовано использовать при необходимости хранения больших массивов данных.
        
    </p>
    <h1>   Исполнение программы     </h1>    
    <p>
        Среди всех регистров процессора в любой архитектуре всегда имеется два выделенных регистра: это регистр PC, что означает Program Counter, по-русски его называют счетчиком команд, и регистр SP — Stack Pointer, т.е. указатель стека. Иногда регистр PC обозначают как IP, что означает Instruction Pointer, указатель инструкции.
        В фон-Неймановской архитектуре, по которой построены все современные компьютеры, программа, состоящая из машинных команд, содержится в оперативной памяти. Регистр PC всегда содержит адрес команды, которая будет выполняться на следующем шаге. Алгоритм работы процессора выглядит следующим образом:
        
    </p>
    <h1>   Последовательное выполнение     </h1>    
    <p>
        При старте процесса создается единица выполнения кода — поток. Потоку передается точка входа — адрес нахождения первой команды программы в адресном пространстве, т.е. начальный адрес сегмента кода. Команды выбираются из памяти и выполняются последовательно, а содержимое регистра PC (program counter) монотонно возрастает. Выполнение команды, однако, может приводить к изменению содержимого регистра PC. Таким образом, организуются безусловные и условные переходы в программе, нарушающие последовательный порядок выполнения команд. С помощью команд условных и безусловных переходов реализуются конструкции ветвления и цикла.
 

    </p>
    <h1>    Вызов функций    </h1>    
    <p>
        Стек
        Стек	вызовов	реализуется	на	базе	оперативной	памяти.	Элементы	стека
        расположены в оперативной памяти, каждый из них занимает одно машинное слово. Регистр процессора SP в любой момент времени хранит адрес элемента в вершине стека. Стек растет в сторону уменьшения адресов: элемент, расположенный непосредственно под вершиной стека, имеет адрес SP + 4 (при условии, что размер слова равен четырем байтам), следующий SP + 8 и т.д. Поскольку регистр SP содержит адрес машинного слова, его значение всегда кратно четырем. При помещении элемента x в стек значение SP сначала уменьшается на 4, затем x записывается в слово оперативной памяти с адресом SP. При извлечении элемента из стека сначала слово с адресом SP копируется в выходную переменную x, затем значение SP, т.е. адрес вершины стека, увеличивается на 4. Для помещения машинного слова в вершину стека служит команда push, а для извлечения машинного слова из вершины стека — команда pop:
        push X	~	SP = SP - 4;
        m[SP] = X;
        pop X	~	X = m[SP];
        SP = SP + 4;
        Здесь через m[SP] обозначается содержимое слова памяти с адресом SP.
        
    </p>
    <h1>    Команды call и ret   </h1>    
    <p>
        Вызов функции подразумевает выполнение операторов, составляющих тело функции с последующим возвратом к оператору следующему за оператором вызова функции. Соответственно, до начала выполнения функции необходимо каким-то образом запомнить адрес команды к которой надо перейти после её выполнения. Можно использовать для этого фиксированную ячейку памяти, однако в этом случае мы теряем возможность вложенных вызовов функций, поэтому в современных архитектурах для хранения адреса возврата используют стек.
        При вызове подпрограммы f исполняется команда call, которая осуществляет переход к подпрограмме f (присваивает регистру PC адрес f) и сохраняет в стеке точку возврата (предыдущее значение регистра PC):
        call f	~	push PC;
        PC = f;
        Для возврата из подпрограммы используется команда ret. Она извлекает из стека адрес возврата и помещает его в регистр PC:
        ret	~	pop PC;
        
    </p>
    <h1>  Передача параметров и возвращаемого значения     </h1>    
    <p>
        Функция может иметь аргументы и возвращать некоторое значение. Для хранения фактических значений аргументов так же используют стек. Вызывающая программа помещает фактические значения аргументов функции на стек, в обратном порядке (на вершине стека лежит первый аргумент функции, под ним — второй аргумент и т.д.).
        Возвращаемое значение, если оно есть, может передаваться одним из двух способов в зависимости от компилятора: через регистры (например регистр процессора EAX для передачи целых чисел и указателей и регистр математического сопроцессора ST0 для передачи чисел с плавающей точкой) либо как неявный дополнительный аргумент, представляющий собой адрес, по которому необходимо сохранить значение (например вызов x = f(a, b, c) будет трансформирован в вызов f(&x, a, b, c);
         
        
    </p>
    <h1> Локальные переменные функции      </h1>    
    <p>
        Перед началом работы функция должна захватить в стеке область памяти под свои локальные переменные. Напомним, что блок локальных переменных функции называется фреймом. Адрес блока локальных переменных функции в момент ее работы помещается в специальный регистр процессора, который называется FP — Frame Pointer, т.е. указатель фрейма (кадра). В первую очередь функция f сохраняет в стеке предыдущее значение регистра FP. Затем значение регистра указателя стека SP копируется в регистр FP. После этого функция f захватывает в стеке область памяти под локальные переменные, для чего просто уменьшается значение регистра SP на требуемое количество машинных слов. Аргументы функции и локальные переменные всегда адресуются относительно указателя фрейма FP.
    </p>
    <h1> Вызов функции     </h1>    
    <p>
        Опишем действия происходящие при вызове следующей функции:
        int f(int x, int y)
        {
        int a, b, c;
        ...
        return c
        }
        
        int main()
        {
        
        ...
        int res = f(39, 82);
        ...
        }
        В нашем примере вызывающая функция main, а вызываемая f.
        
    </p>
    <h1> Действия вызывающей функции перед вызовом       </h1>    
    <p>
        1.	Функция main кладёт на стек аргументы, начиная с последнего.
        2.	Вызов функции с помощью команды call.
        push 82
        push 39 call f
        
        
        
        SP-->
        
    </p>
    <h1> Действия вызываемой функции после вызова       </h1>    
    <p>
        1.	Функция f кладёт на стек текущее значение регистра FP.
        2.	Функция f сохраняет в регистре FP текущее значение регистра SP.
        3.	Функция f выделяет на стеке память под свои локальные переменные.
        push FP
        mov FP, SP (FP = SP)
         
        sub SP, 12 (SP = SP - 12)
        Аргументы и локальные переменные функции f адресуются относительно регистра FP. Так, аргумент x имеет адрес FP+8, аргумент y - адрес FP+12. Переменная a имеет адрес FP-4, переменная b - адрес FP-8, переменная c - адрес FP-12.
        
            ...	
        SP-->	переменная c	[FP-12]
            переменная b	[FP-8]
            переменная a	[FP-4]
        FP-->	FP main	
            адрес возврата main	
            аргумент x = 39	[FP+8]
            аргумент y = 82	[FP+12]
            ...	
        Теперь может быть выполнено тело функции. При этом новые данные могут помещаться и извлекаться из стека. Поэтому указатель стека SP может изменяться, но указатель фрейма FP остаётся фиксированным, и к первому аргументу можно обратиться [FP+8] независимо от того, сколько операций push и pop было вызвано. Выполнение функции f в свою очередь также может привести к вызову других функций или к рекурсивному вызову. Тем не менее, поскольку значение регистра FP восстанавливается после возвращения из этих вложенных вызовов, ссылки на аргументы и локальные переменные относительно FP остаются корректными.
        
    </p>
    <h1>  Действия вызываемой функции перед возвратом      </h1>    
    <p>
        1.	Функция f сохраняет возвращаемое значение (либо в регистр, либо в дополнительный аргумент).
        2.	Функция f освобождает стековую память занятую локальными переменными.
        3.	Функция f восстанавливает значение предыдущее значение указателя кадра FP.
        4.	Завершение функции с помощью команды ret.
        mov EAX, c (EAX = c)
        add SP, 12 (SP = SP + 12)
        pop FP ret
        
        
        
        SP-->
         
        
    </p>
    <h1>   Действия вызывающей функции после возврата     </h1>    
    <p>
        1.	Функция main освобождает стековую память занятую аргументами функции f.
        2.	Сохранение возвращаемого значения в переменную.
        add SP, 8 (SP = SP + 8)
        mov res, EAX (res = EAX)
        
            ...
        SP-->	...
        Таким образом, стек опять находится в исходном состоянии, в котором был до вызова функции f, а выполнение программы продолжится с оператора функции main, следующего после вызова функции f.
        
    </p>

</body>
</html>